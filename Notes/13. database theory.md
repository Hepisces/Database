---
number headings: auto, first-level 1, max 6, start-at 13, 1.1.
---
# 13. database theory
## 13.1. stockpile
## 13.2. Index

A database index is a data structure that improves the speed of data retrieval operations on a database table at the cost of additional writes and storage space to maintain the index data structure.

### 13.2.1. category

- ordered index : value based
- hash index

### 13.2.2. ordered index

#### 13.2.2.1. clustering v.s. non-clustering index

If the search code of the index also `determines the order of the records` in the containing file
On the other side, if the index differ from the records, then it will be non-clustering index/secondary index.

The file organization  that clustering index rely on is `sequential file organization`

A table cannot have multiple clustering index, since you can't guarantee that two search codes will exactly match the sorting in the same file, as how clustering is defined

The primary key of the MySQL InnoDB engine is automatically an clustering index; SQL Server supports both; other DBMSs mainly support non-clustering indexes.

#### 13.2.2.2. dense v.s. sparse index

In a dense index, an index entry appears for every search-key value in the file

sparse index cannot be an non-clustering index, because it would throw subsequent indexing out of whack

### 13.2.3. B+ Tree Index
properties:
B+ trees are balanced with heights of order log N; a B+ node is typically within a page (typically 4 KB).
- Each non-leaf node (except the root node) has between n/2 and n children.
- The number of children of the root node is between 2 and n.

practice:
Assuming a pointer of 8 bytes and a search code of 32 bytes, then n is about 100. Assuming 1 million records, then at most one B+ tree node needs to be accessed: 5

### 13.2.4. Hash Index 
A hash function is any function that can be used to map data of arbitrary size to fixed-size values

Hash indexes support only = operators, not range queries, as their random nature

Thinkï¼šAssuming that 1 page (4KB) can hold 100 index entries, then for 100,000,000 tuples, 1,000,000 pages (i.e., 4GB) are needed to hold the index. Given the memory constraints, what should be done?
Build the index based on the index, Multi-level index

## 13.3. Query plan

![attachments/Pasted image 20250605205705.png](attachments/Pasted%20image%2020250605205705.png)
basic steps: 
- parsing: Converting SQL statements to internal representations
- optimization: Generate a query plan
- execution: Execute the query plan

### 13.3.1. query optimization 
predicate push down i.e. filter first 

e.g. 
```sql
 select salary
  from instructor 
  where salary < 75000;
```

`where first,` then select , faster than select first
